<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aleira N. Sanchez - Labs</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Navigation Bar -->
    <nav>
        <a href="index.html" class="logo">Aleira N. Sanchez</a>
        <ul>
            <li><a href="index.html">Go back</a></li> <!-- Link back to the main page -->
        </ul>
    </nav>

    <button class="home-button" onclick="goHome()">Return to Home</button>

    <script>
        function goHome() {
            window.location.href = "index.html"; // Adjust if your homepage is in a different folder
        }
    </script>

    
    <!-- Labs Details Section -->
    <section id="labs-subpage">
        <div class="gallery">


<!-- --------LAB 3-------- -->
            
            
    <!-- --------LAB 4-------- -->
            <section id="lab4">
                <div class="lab-text">
                    <h1>Lab 4: Motor Drivers and Open Loop Control</h1>
                    <h2>PRE-LAB</h2>
                    <h3>WIRING DIAGRAM: <span class="objective-text"> I started by reviewing the lecture notes and then taking a look at what Nila Narayan and Mikayla Lahr did last year. I then came up with this wiring diagram where AIN1 and BIN1 are connected in series to pin 0 and 4, for motor drivers 1 and 2 respectively. AIN2 and BIN2 follow the same setup but in pins 1 and 5, for motor drivers 1 and 2 respectively. And then, AOUT1 with BOUT1 and AOUT2 with BOUT2 are connected in series with eachother and then solder to each positive and negative lead of the DC motor, respectively.</span></h3>
                    <img src="motorDriverwires.jpg" alt="Motor drivers' wiring" class="lab-image">
                    <br>
                    <h3>BATTERY DISCUSSION: <span class="objective-text">The Artemis board and the motors are powered separately to keep everything running smoothly. Motors can cause sudden changes in current, which might mess with the Artemis and make it glitch or reset. Using separate batteries prevents those power spikes from interfering with the board. Plus, motors need more power, so giving them their own battery makes sure they get enough without affecting the Artemis.</span></h3>
                    <br>

                    <h2>TASKS</h2>
                    <h3>PWM TESTS:</h3>
                    <p>Before soldering the motor drivers to the motors themselves, I connected every OUT pin individually to the oscilloscope to make sure it is reading and ooutputting corrrectly. To do this, I connected the VIN and GND pins of the motor driver to the power supply and sent an output of around 3.7V which is a reasonable input voltage withing their 10V range. Below you can see my setup with a motor driver connected to the oscilloscope and power supply.  </p>
                    <img src="IMG_7260.jpg" alt="Power supply setup" class="lab-image">
                    <p> This is the code I burned on the Artemis to see if I can regulate the power on the motor driver output.</p>
                    <img src="analogCode.png" alt="Analog code for oscilloscope" class="lab-image">
                    <p>Here is an image of the output of the oscilloscope (each OUT pin), this plot remained constant when sending a 200 PWM signal to each OUT pin.</p>
                    <img src="IMG_7256.jpg" alt="Power supply setup" class="lab-image">
                    
                    <h3>TESTING INDIVIDUAL MOTORS:</h3>
                    <p>I proceeded to wire the motors and upload code to the Artemis board that will run one set of the wheels forward and then the same one backwards. The other set of wheels' code was commented out when working on this part. This is the code: </p>
                    <img src="eachSet_turns.png" alt="Each wheel set turns" class="lab-image">
                    <p>This is how the robot reacted:</p>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/ybmaBvgfM-c?si=L4XBTq2sPk4HABGf" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/-5GV7pHTpVw?si=HC6hKRZ0vKLp8eci" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

                    <h3>FULLY BATTERY POWERED MOTOR DRIVERS:</h3>
                    <p>Here I then moved from the power supply to the 850mAh battery given to us. And after some soldering, I was able to connect all the wires and upload this code:</p>
                    <img src="allWheels_turn.png" alt="All wheels turn" class="lab-image">
                    <p>In which the wheels moved as so:</p>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/RevvYjTSwGw?si=40AmAM1Pn_3-7dXc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    
                    <h3>CAR CHASSIS SETUP:</h3>
                    <img src="robot_components.jpeg" alt="Robot components" class="lab-image">

                    <h3>LOWER LIMIT PWM:</h3>
                    <p>For the task where we tested the motor drivers running entirely on battery power, I wrote a simple code to make the car move forward for a few seconds and then backward. Since I was testing the motors, I decided to lower the PWM values—not only to observe their effects but also because I had limited space to run the car. I first reduced the PWM value to 100, then to 50, and finally to 45 to see if the car could move even slower. From these tests, I observed that at a PWM of 50, the car could complete its commands, but after a while, it started getting stuck as friction overpowered the movement. At 45, the car couldn't start at all, suggesting that this value is close to the minimum PWM required for the car to move. </p>
                    
                    <h3>CALIBRATION:</h3>
                    <p>Before showing my calibrated code, let's take a look at how my robot performed when commanded to drive straight for 3 seconds at 60 PWM, so it reaches 6ft (the end of the blue tape is 6ft):</p>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/qPRmzwZZ9xA?si=2PZAgihux8f_qxcO" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    
                    <p>As you can see, my right wheels are moving faster than my left wheels. To calibrate this, I made an estimated guess for an initial value, starting at 1.2 and increasing it by 0.2 until I reached 1.8, where the robot was able to move in a straight line for 6 feet</p>
                    <p>While running these calibration tests, I noticed that the robot would sometimes move forward in small pulses. I found this strange, so I checked the wiring and discovered that the lead of one of the motor driver's soldered GND wires wasn't cut down properly and was touching the Vin wire. After fixing this issue, the car worked as expected.</p>
                    <p>This is how the car performed after including the calibration factor into the code: </p>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/bQ-fnFbHAkY?si=51lPf-r2BKMt4oxn" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    <p>The loop function was getting long so I started making functions for each command and this is the code the car ran:</p>
                    <img src="straightLineCode1.png" alt="Straight Line calibrated code1" class="lab-image">
                    <img src="straightLineCode2.png" alt="Straight Line calibrated code2" class="lab-image">

                    <h3>ADDING TURNS:</h3>
                    <p>For this part, I added a simple turn function to my code. Since the pins for moving forward are 0 and 5, and the pins for moving backward are 1 and 4, the pins for turning would be 0 and 4 for a left turn and 5 and 1 for a right turn.</p>
                    <img src="turn function.png" alt="Turn function" class="lab-image">
                    <img src="turn addition loop.png" alt="Turn function" class="lab-image">
                    <p>And this is how the robot performed with a turn:</p>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/-YFFgVuFQaU?si=0Qafong4edcvi5XP" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>


                    <h2>REFERENCES</h2>
                    <p>For this Lab I referenced the past lab reports of Mikayla Lahr, Nila Narayan and Patty Meza. I used ChatGPT to fix my grammar and spelling. Also went to office hours during the weekend and the late session on Monday night, very much appreciated. </p>
                    
                <a href="index.html#lab4">Back to Lab 4 on main page</a> 
            </section>

            
  <!-- --------LAB 5-------- -->
            <section id="lab5">
                <div class="lab-text">
                    <h1>Lab 5: Linear PID and Linear Interpolation</h1>
                    <h2>PRE-LAB</h2>
                    <h3>BLUETOOTH: <span class="objective-text"> In the Pre-lab, I developed a method to send and receive PID data via Bluetooth, allowing for data collection and debugging. To implement this, I created a flag in Arduino that I constantly check its state in my main loop to act accordingly and several new commands: </span></h3>
                    <ul>
                        <li><strong>START_PID:</strong> Clears all previously stored data, starts ToF sensor ranging and clock and sets the <code>PID_live</code> flag to <code>true</code> (initialized as <code>false</code> at the start of the sketch).</li>
                        <li><strong>STOP_PID:</strong> Resets the <code>PID_live</code> flag to <code>false</code> and stops the motors.     </li>
                        <li><strong>SET_PID_GAINS:</strong> Receives input values from Python and updates the PID gain constants globally in Arduino.</li>
                        <li><strong>SEND_PID:</strong> Transmits the collected PID data to the computer via Bluetooth.</li>
                    </ul>
                    <pre><code>
case START_PID:{
    success = robot_cmd.get_next_value(goalDist);
    if (!success) return;
    limit_dist = goalDist;

    int pid_idx = 0;
    sumError = 0;  
    last_error = 0;
    last_time = millis();  

    t1 = millis();
    t2 = 0;
    d1 = 0;
    d2 = 0;

    PID_live = true;
                        
    break;}


case STOP_PID:{
    PID_live = false;
    stop_motors();

    break;}

                        
case SET_PID_GAINS:{
    float nKp, nKi, nKd;
    success = robot_cmd.get_next_value(nKp);
    if (!success)
        return;

    success = robot_cmd.get_next_value(nKi);
    if (!success)
        return;

    success = robot_cmd.get_next_value(nKd);
    if (!success)
        return;

    K_p = nKp;
    K_i = nKi;
    K_d = nKd;

    break;}

                        
case SEND_PID:
{
    for (int i = 0; i < ArraySize; i++) {
        tx_estring_value.clear();
        tx_estring_value.append(time_pid[i]);
        tx_estring_value.append(",");
        tx_estring_value.append(distance_array1[i]);
        tx_estring_value.append(",");
        tx_estring_value.append(motor_speedArray[i]);
        tx_characteristic_string.writeValue(tx_estring_value.c_str());
    }
    break;}
                    </code></pre>
                    <p>On the Python side, my notification handler remained largely the same as in Lab 3, with only the variable names modified. Which you can see below as well as how I called my commands:</p>
                    <img src="PID_notif.png" alt="PID notification handler" class="lab-image">
                    <img src="commandsPID.png" alt="Commands PID" class="lab-image">
                    
                    <h2>TASKS</h2>
                    <h3>P-CONTROL:</h3>
                    <p>For the P controller, I wrote code in the <code>loop</code> function that continuously checks the state of the <code>PID_live</code> flag. When <code>PID_live</code> is true, the robot starts collecting data and adjusts its movement based on its distance from the goal. It either moves forward or reverses accordingly. The speed for this adjustment is calculated by a separate function I created, <code>pos_control</code>, which returns the PWM value for the proportional control term.</p>
                    <pre><code>
void loop(){
...if bluetooth connected...

    if (PID_live){  
        float distance1;
        float motor_speed;

        while (!TOFSensor1.checkForDataReady()){}
        distance1 = TOFSensor1.getDistance(); //distance in mm
        TOFSensor1.clearInterrupt();
        TOFSensor1.stopRanging();
        TOFSensor1.startRanging();
            
        //P-control
        motor_speed = pos_control(distance1, limit_dist);

        if(pid_idx < ArraySize){
            distance_array1[pid_idx] = distance1;
            motor_speedArray[pid_idx] = motor_speed;
            time_pid[pid_idx] = (float) millis() - time_pid_start;
        }
        pid_idx++; 
            
        if (motor_speed > 0){ //drive forward
            straightLine(0, motor_speed); }
        else if (motor_speed < 0){ //drive backward
            straightLine(1, abs(motor_speed)); }
        else {
            stop_motors(); }
            
    }
          
}

float pos_control(float actual_dist, float goal_dist) {
  float error = actual_dist - goal_dist;
            
  //P-control------------
  float p_control = K_p * error;
  
  if (p_control > 0) {
    if (p_control > max_speed) p_control = max_speed;
    return p_control; }
  else if (p_control < 0) {
    if (p_control < -max_speed) p_control = -max_speed;
    return p_control; }
  return p_control; }
                    </code></pre>
        
                    <p>I conducted several tests with different gain values, starting at 0.1 and then adjusting to 0.05. With Kp = 0.1, the robot would crash into the wall before reversing, while with Kp = 0.05, it stopped too early, leaving a significant gap from the target. After further testing, I found that a gain of 0.08 yielded the best results, with the robot stopping at approximately 350 mm—about 50 mm short of the goal distance. </p>
                    <table>
                        <tr>
                            <td><img src="Pcontrol_tofPlot.png" alt="P-control ToF plot" width="300"></td>
                            <td><img src="Pcontrol_pwmPlot.png" alt="P-control PWM plot" width="300"></td>
                        </tr>
                    </table>
                    <h3>PI-CONTROL:</h3>
                    <p>For my PI-control I ran into many issues. In many cases the car would just ran straight to the wall, back up and go again and then it would reach steady state at around the right value. When I ran that code with a Ki value of 0.01. I got these values: </p>
                    <table>
                        <tr>
                            <td><img src="PIcontrol_hmm_pwmPlot.png" alt="PI-control ToF plot" width="300"></td>
                            <td><img src="PIcontrol_hmm_tofPLot.png" alt="PI-control PWM plot" width="300"></td>
                        </tr>
                    </table>
                    <p>I did perfect my code, but by that time my battery had died so I could only run it while connected to the computer and just see the output by the print statements in the serial monitor. I ran this code with a Ki value of 0.01 and started the robot at around 15 inches ~ 370 mm and then went oscillating from there to 304mm. When I was about to reach the goal distance, the error blew up (not seen in the video, I stopped recording too early).</p>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/wngom8DBLb0?si=qKRWBR-iqCVGDtxh" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                    <p>Given these tests, I decided to go with a smaller Ki value, around 0.0001. Just because 0.01 proved itself wrong multiple times so I think decreasing as much as possible would be the best for a Ki value.</p>
                    
                    <h3>PID-CONTROL:</h3>
                    <p>My battery died at this point, but I was able to do my code and debug it while having the robot connected to my computer and just printing out statements and data in the serial monitor. I ran this code with the values of Kp=0.08, Ki=0.0001 and Kd = 0.5. Started the robot at around 15 inches ~ 370 mm and then went oscillating from there to 304mm.</p>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/Ssre-k2j1Ew?si=axJSg_uu9wuuFhgE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        
<!--                     <h3>SAMPLING FREQUENCY:</h3>
                    <p></p> -->
        
                    <h3>LINEAR INTERPOLATION:</h3>
                    <p>For the linear interpolation I just calculated the distance in my loop function with the previous two data points. I did change my full loop function so I'm going to include the full function with that part emphasized in the comments:</p>
                    <pre><code>
void loop(){
...if bluetooth connected...
                        
    TOFSensor1.startRanging();
    if (PID_live){  
        float distance1;
        float pid_error;
        float sumStop;

        time_pid[pid_idx] = (float)millis();

        if (TOFSensor1.checkForDataReady()) {
          distance1 = TOFSensor1.getDistance();  //distance in mm
          sumStop = 0.5*distance_array1[0];
          t2 = t1;
          t1 = (float)millis();
          d2 = d1;
          d1 = distance1;
          data =+ 1;
        }
        else if (!TOFSensor1.checkForDataReady() ) {
          //LINEAR INTERPOLATION
          float slope = (d2-d1)/(t2-t1);
          distance1 = (((float)millis()-t1)*slope) + d1;
        }
        distance_array1[pid_idx] = distance1;

        float dt = millis() - last_time;
        errorss[pid_idx] = distance1 - limit_dist;

        motor_speed = pos_control(errorss[pid_idx], sumStop, dt);  //in units of pwm

        if (pid_idx < ArraySize) {  //meaning data was collected/calculated
          distance_array1[pid_idx] = distance1;
          motor_speedArray[pid_idx] = motor_speed;
        }
        pid_idx++;
        
        last_time = millis();

        if (motor_speed > 0) straightLine(0, motor_speed);            //forward
        else if (motor_speed < 0) straightLine(1, abs(motor_speed));  //back
        else {
            stop_motors();
            sumError = 0;
        }
        
    }
} 

                    </code></pre>
                        
                    <h3>5000 - WIND UP:</h3>
                    <p>I implemented the wind up for my integrator in my pos_control function. When the wind up was not implemented the sum of the error kept incrementing and at first I was running the code without it and the robot would run straight to the wall, crash, do a flip and then I would stop it. At lab when I ran it again, it went straight to the wall at full speed, backed up at full speed, did a flip and then the battery came off. I then talked with my TA and I refined my wind up which now is like this:  </p>
                    <pre><code>
  float pos_control(float pid_error, float stop, float timelapsed) {
  float i_control;
  if (pid_error > stop) {
    sumError = sumError + (pid_error * timelapsed); 
    sumError = constrain(sumError, -1000, 1000);
    i_control = K_i * sumError;
    if (i_control > 100) i_control = 100;
    else if (i_control < -100) i_control = -100; 
    }
  else i_control = 0;

  p_control = K_p * pid_error;

  float dError = (pid_error - last_error) / timelapsed;
  float d_control = K_d * dError;
  
  float speed = p_control + i_control + d_control;

  last_error = pid_error; //reset
  last_time = millis(); //reset

  return speed;}
                    </code></pre>
                    <h3>References:</h3>
                    <p>For this Lab I referenced the past lab reports of Nila Narayan, Mikayla Lahr and Stephan Wagner.</p>
                    <br>
        
                <a href="index.html#lab5">Back to Lab 5 on main page</a> 
            </section>

            
 <!-- --------LAB 6-------- -->
            <section id="lab6">
                <div class="lab-text">
                    <h1>Lab 6: Orientation PID</h1>
                    <h2>PRE-LAB</h2>
                    <h3>IMPROVING LAB 5: 
                        <span class="objective-text"> To start this lab, I ran my Lab 5 code multiple times and perfected it. During this debugging process, because I had changed my code from what I had initially, my calibration factor for the wheels ended up decreasing from 1.8 to 1.6. And when I ran my PID, the final control values that work best were: Kp = 0.08, Ki = 0.00001, Kd = 0.8. My final Lab 5 code is:
                        </span>
                    </h3>
                    <p><a href="finalLab5code.png" target="_blank">Lab 5 code</a></p>
                    <h3>BLUEETOOTH: 
                        <span class="objective-text"> ...
                        </span>
                    </h3>
                   
                <p>...</p>
                <a href="index.html#lab6">Back to Lab 6 on main page</a> 
            </section>

            
 <!-- --------LAB 7-------- -->
            <section id="lab7">
                <h2>Lab 7: Kalman Filtering</h2>
                <p>Details about Lab 7...</p>
                <a href="index.html#lab7">Back to Lab 7 on main page</a> 
            </section>

            
 <!-- --------LAB 8-------- -->
            <section id="lab8">
                <h2>Lab 8: Stunts!</h2>
                <p>Details about Lab 8...</p>
                <a href="index.html#lab8">Back to Lab 8 on main page</a> 
            </section>

            
 <!-- --------LAB 9-------- -->
            <section id="lab9">
                <h2>Lab 9: Mapping</h2>
                <p>Details about Lab 9...</p>
                <a href="index.html#lab9">Back to Lab 9 on main page</a> 
            </section>

            
 <!-- --------LAB 10-------- -->
            <section id="lab10">
                <h2>Lab 10: Localization (sim)</h2>
                <p>Details about Lab 10...</p>
                <a href="index.html#lab10">Back to Lab 10 on main page</a> 
            </section>

            
 <!-- --------LAB 11-------- -->
            <section id="lab11">
                <h2>Lab 11: Localization (real)</h2>
                <p>Details about Lab 11...</p>
                <a href="index.html#lab11">Back to Lab 11 on main page</a> 
            </section>

            
 <!-- --------LAB 12-------- -->
            <section id="lab12">
                <h2>Lab 12: Planning and Execution</h2>
                <p>Details about Lab 12...</p>
                <a href="index.html#lab12">Back to Lab 12 on main page</a> 
            </section>
        </div>
    </section>

<button id="backToTop">↑ Back to Top</button>
    
    <!-- Footer -->
<!--     <footer>
        <p>&copy; 2025 Aleira Sanchez. All rights reserved.</p>
    </footer> -->
</body>
</html>
